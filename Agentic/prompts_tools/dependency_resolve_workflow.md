
### **代码合并工作流**

**目标：** 将新的代码片段合并到现有的 `design.h` 和 `design.c` 文件中，并报告任何缺失的依赖项。

---

#### **第一步：接收与分析输入**

1.  **接收当前设计：** 获取用户提供的 `design.h` 和 `design.c` 文件的现有内容。
2.  **接收待合并代码片段：** 获取用户希望合并到设计中的一个或多个 C 语言代码片段（例如，函数定义、结构体定义等）。
3.  **接收特殊指令（如有）：** 检查是否有针对特定符号（函数名、类型名等）的特殊处理指令。这些指令的优先级最高。

---

#### **第二步：应用合并策略，处理代码片段**

对于每一个待合并的代码片段，严格按照以下规则进行处理和修改。核心原则是**最小化实现差异**。

1.  **替换占位符：**
    *   如果用户要求将某个代码合并到设计中，但在当前设计中已经能找到一个对应的占位符实现（例如，空函数、返回常量值的函数、空结构体等），那么就删掉这个占位符，用代码片段中提供的真实实现来替换它。

2.  **移除日志与打印语句：**
    *   检查代码片段中所有用于打印或记录日志的语句/函数调用（例如 `printf`, `fprintf`, `log_info` 等）。
    *   **必须**将它们直接替换为无操作（NO-OP）或一个接口相同但函数体为空的桩函数。例如，将 `printf("value is %d", x);` 直接删除，或者将对 `log_info(...)` 的调用保留，但确保 `log_info` 函数的定义是空的 `void log_info(...) {}`。

3.  **移除外部依赖：**
    *   如果代码片段的实现依赖于外部库、特定项目或特定硬件的代码。用一个功能简化但**接口完全相同**的标准 C 版本来替代它。目标是解除对非标准环境的依赖。注意：当前文件所在的项目不属于外部，外部指的是当前的项目需要用到一个其他的项目。
    *   移除所有系统层的调用，例如文件操作、网络通信、多线程、操作系统内核交互、中断、异常、硬件寄存器访问、ASM 内联等。对于这些情况，提供一个空实现或返回默认值的实现。
    *   对于这种情况，在代码中提供一个注释，说明该实现是一个简化版本，原始实现依赖于外部系统/库。

4.  **头文件包含 (`#include`)：**
    *   检查代码是否需要依赖标准 C 库的头文件（如 `stdio.h`, `stdlib.h`, `string.h` 等）。
    如果是，加上这些标准头文件的包含语句。
    *   除了标准头文件外，你只需要在`design.c`中额外包含`design.h`即可。
    *   除上面两种情况外，不需要考虑任何其他头文件的包含。

5.  **移除条件编译指令：**
    *   移除所有的条件编译指令（`#ifdef`, `#ifndef`, `#if`, `#else`, `#elif`, `#endif`）以及它们所包含的分支。
    *   **只保留**在标准 C 环境（假定为 Ubuntu/Linux、GCC 编译器、Intel x86-64 架构）下或最通用情况下会生效的代码路径。

6.  **移除存储类别与链接说明符：**
    *   移除所有用于修饰存储类别或链接方式的关键字，例如 `static`, `extern`, `register`, `volatile`, `inline`。
    *   同时移除项目自定义的、用于修改存储或链接方式的宏。

---

#### **第三步：处理并记录缺失的依赖项**

你不需要保证代码必须编译正确。 你的任务是尽可能地合并代码，并准确地报告所有缺失的符号。
只有当所有的符号都被正确地加入到设计中后，代码才能被认为是完整的，我们才会进行编译测试。

因此，在执行第二步的过程中，如果发现合并后的代码需要一些当前设计和标准库中都没有定义的符号（数据结构、辅助函数、宏等），**绝不能**随意创建它们的实现。

【严格遵守】不论出现什么情况，都不允许提供他的定义、声明、实现等任何内容。坚决不允许，你不需要思考如果不提供它们，代码是否能编译通过。

**记录符号名称：**
你必须将【所有】你发现的缺失的符号的**名称**记录在一个列表中，以备最后输出。
对于自定义结构体类型，你只需要记录类型名称，不需要记录他们的成员（fields）名称。

---

#### **第四步：整理代码并格式化输出**

1.  **确保正确的顺序和位置：**
    *   在生成最终的 `design.h` 和 `design.c` 文件内容时，根据标准的 C 语言编程实践，调整函数、类型和宏的声明与定义顺序。
    *   目标是确保先后顺序符合依赖关系，避免出现已经定义但因为顺序错误而无法使用的情况。
    *   对于符合类型，考虑是否需要typedef等。例如，如果代码使用`struct SymbolName`，那么就可以不加typedef；但如果代码使用`SymbolName`，那么就需要加上`typedef struct SymbolName SymbolName;`。

2.  **生成最终输出：**
    *   严格按照指定的格式，生成包含三个部分的最终答案。
    *   **部分一：** 提供一个包含 `design.h` 内容的 C 代码块。
    *   **部分二：** 提供一个包含 `design.c` 内容的 C 代码块。
    *   **部分三：** 提供一个包含所有缺失符号名称的列表，每行一个符号名称，无其他附加文本，
    
格式如下：

```c
<design.h 的内容>
```

```c
<design.c 的内容>
```

```
symbol_1
symbol_2
...
```
